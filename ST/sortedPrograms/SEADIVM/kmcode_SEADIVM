#include<bits/stdc++.h>
using namespace std;
#define SOLVE_LIM 3
unsigned int randxor()
{
	static unsigned int x = 123456789, y = 362436069, z = 521288629, w = 88675123;
	unsigned int t;
	t = (x ^ (x << 11)); x = y; y = z; z = w; return(w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));
}
int t;
#define MAXX 102
#define MAX 101
#define MAX_VAL 1002
unsigned seed;
struct parts{
	int x;
	int xx;
	int y;
	int yy;
	parts(int x_, int xx_, int y_, int yy_){
		if (x_ > xx_){
			swap(x_, xx_);
		}
		if (y_ > yy_){
			swap(y_, yy_);
		}
		x = x_;
		xx = xx_;
		y = y_;
		yy = yy_;
	}
	int area(){
		return (xx - x + 1)*(yy - y + 1);
	}
};
namespace optimize{
	vector<int> g[MAX][MAX];
	void connect_h(vector<parts> &v){  //x is always equal
		for (int i = 0; i < MAX; i++){
			for (int j = 0; j < MAX; j++){
				g[i][j].clear();
			}
		}
		for (int i = 0; i < v.size(); i++){
			for (int k = v[i].x; k <= v[i].xx; k++){
				g[v[i].y][v[i].yy].push_back(v[i].x);
			}
		}
		v.clear();
		for (int i = 0; i < MAX; i++){
			for (int j = 0; j < MAX; j++){
				if (g[i][j].size()){
					sort(g[i][j].begin(), g[i][j].end());
					int z = 0;
					for (int k = 0; k < g[i][j].size(); k++){
						if (k + 1 < g[i][j].size()){
							if (g[i][j][k + 1] - g[i][j][k] <= 1){
								continue;
							}
						}
						v.push_back(parts(g[i][j][z], g[i][j][k], i, j));
						z = k + 1;
					}
				}
			}
		}
	}
	void connect_y(vector<parts> &v){  //y is always equal
		for (int i = 0; i < MAX; i++){
			for (int j = 0; j < MAX; j++){
				g[i][j].clear();
			}
		}
		for (int i = 0; i < v.size(); i++){
			for (int k = v[i].y; k <= v[i].yy; k++){
				g[v[i].x][v[i].xx].push_back(k);
			}
		}
		v.clear();
		for (int i = 0; i < MAX; i++){
			for (int j = 0; j < MAX; j++){
				if (g[i][j].size()){
					sort(g[i][j].begin(), g[i][j].end());
					int z = 0;
					for (int k = 0; k < g[i][j].size(); k++){
						if (k + 1 < g[i][j].size()){
							if (g[i][j][k + 1] - g[i][j][k] <= 1){
								continue;
							}
						}
						v.push_back(parts(i, j, g[i][j][z], g[i][j][k]));
						z = k + 1;
					}
				}
			}
		}
	}
	void all(vector<parts> &v){
		connect_h(v);
		connect_y(v);
	}
}
class solve1{
public:
	int n;
	int m;
	int countt[MAX_VAL];
	int a[MAX][MAX];
	void sett(int n_, int m_, int countt1[MAX_VAL], int A[MAX][MAX]){
		n = n_;
		m = m_;
		for (int i = 0; i < MAX_VAL; i++){
			countt[i] = countt1[i];
		}
		for (int i = 0; i < n; i++){
			for (int j = 0; j < m; j++){
				a[i][j] = A[i][j];
			}
		}
	}
	bool use[MAX][MAX];
	int sereja[MAX_VAL];
	vector<parts> vv;
	vector<parts> ato;
	void divide_parts(){
		ato.clear();
		for (int i = 0; i < n; i++){
			for (int j = 0; j < m; j++){
				if (use[i][j] == false){
					if (sereja[a[i][j]] == countt[a[i][j]] / 2){
						ato.push_back(parts(i, i, j, j));
					}
					else{
						sereja[a[i][j]]++;
						vv.push_back(parts(i, i, j, j));
					}
				}
			}
		}
		//optimize::connect_h(vv);
		//optimize::connect_y(ato);
		if (vv.size()>ato.size()){
			swap(vv, ato);
		}
	}
	void solve(){
		vv.clear();
		memset(sereja, 0, sizeof(sereja));
		for (int i = 0; i < n; i++){
			for (int j = 0; j < m; j++){
				use[i][j] = false;
			}
		}
		for (int k = 0; k < n; k++){
			int l = 0;
			while (l < m){
				if (sereja[a[k][l]] == countt[a[k][l]] / 2){
					l++;
					continue;
				}
				int j = l;
				while (j < m){
					sereja[a[k][j]]++;
					use[k][j] = true;
					bool flag1 = false;
					if (j + 1 < m){
						if (sereja[a[k][j + 1]] == countt[a[k][j + 1]] / 2){

						}
						else{
							flag1 = true;
						}
					}
					if (flag1){
						j++;
					}
					else{
						break;
					}
				}
				vv.push_back(parts(k, k, l, j));
				l = j + 1;
			}

		}
		divide_parts();
		optimize::connect_h(vv);
		//	compare(vv);
	}
};
class solve2{  //similar to solve1
public:
	int n;
	int m;
	int countt[MAX_VAL];
	int a[MAX][MAX];
	void sett(int n_, int m_, int countt1[MAX_VAL], int A[MAX][MAX]){
		n = n_;
		m = m_;
		for (int i = 0; i < MAX_VAL; i++){
			countt[i] = countt1[i];
		}
		for (int i = 0; i < n; i++){
			for (int j = 0; j < m; j++){
				a[i][j] = A[i][j];
			}
		}
	}
	bool use[MAX][MAX];
	int sereja[MAX_VAL];
	vector<parts> vv;
	vector<parts> ato;
	vector<int> order;
	void ini(){
		order.clear();
		for (int i = 0; i < n; i++){
			order.push_back(i);
		}
	}
	void divide_parts(){
		ato.clear();
		for (int i = 0; i < n; i++){
			for (int j = 0; j < m; j++){
				if (use[i][j] == false){
					if (sereja[a[i][j]] == countt[a[i][j]] / 2){
						ato.push_back(parts(i, i, j, j));
					}
					else{
						sereja[a[i][j]]++;
						vv.push_back(parts(i, i, j, j));
					}
				}
			}
		}
		if (vv.size()>ato.size()){
			swap(vv, ato);
		}
	}
	void solve(){
		vv.clear();
		memset(sereja, 0, sizeof(sereja));
		for (int i = 0; i < n; i++){
			for (int j = 0; j < m; j++){
				use[i][j] = false;
			}
		}
		//shuffle(order.begin(), order.end(), default_random_engine(seed));
		random_shuffle(order.begin(), order.end());
		for (int k = 0; k < n; k++){
			int kk = k;
			k = order[k];
			int l = 0;
			while (l < m){
				if (sereja[a[k][l]] == countt[a[k][l]] / 2){
					l++;
					continue;
				}
				int j = l;
				while (j < m){
					sereja[a[k][j]]++;
					use[k][j] = true;
					bool flag1 = false;
					if (j + 1 < m){
						if (sereja[a[k][j + 1]] == countt[a[k][j + 1]] / 2){

						}
						else{
							flag1 = true;
						}
					}
					if (flag1){
						j++;
					}
					else{
						break;
					}
				}
				vv.push_back(parts(k, k, l, j));
				l = j + 1;
			}
			k = kk;
		}
		divide_parts();
		optimize::connect_h(vv);
		//	compare(vv);
	}
};
class solve3{
public:
	int n;
	int m;
	int countt[MAX_VAL];
	int a[MAX][MAX];
	void sett(int n_, int m_, int countt1[MAX_VAL], int A[MAX][MAX]){
		n = n_;
		m = m_;
		for (int i = 0; i < MAX_VAL; i++){
			countt[i] = countt1[i];
		}
		for (int i = 0; i < n; i++){
			for (int j = 0; j < m; j++){
				a[i][j] = A[i][j];
			}
		}
	}
	bool use[MAX][MAX];
	int sereja[MAX_VAL];
	vector<parts> vv;
	vector<parts> ato;
	void divide_parts(){
		ato.clear();
		for (int i = 0; i < n; i++){
			for (int j = 0; j < m; j++){
				if (use[i][j] == false){
					if (sereja[a[i][j]] == countt[a[i][j]] / 2){
						ato.push_back(parts(i, i, j, j));
					}
					else{
						sereja[a[i][j]]++;
						vv.push_back(parts(i, i, j, j));
					}
				}
			}
		}
		if (vv.size()>ato.size()){
			swap(vv, ato);
		}
	}
	void solve(){
		vv.clear();
		memset(sereja, 0, sizeof(sereja));
		for (int i = 0; i < n; i++){
			for (int j = 0; j < m; j++){
				use[i][j] = false;
			}
		}
		for (int k = 0; k < m; k++){
			int l = 0;
			while (l < n){
				if (sereja[a[l][k]] == countt[a[l][k]] / 2){
					l++;
					continue;
				}
				int j = l;
				while (j < n){
					sereja[a[j][k]]++;
					use[j][k] = true;
					bool flag1 = false;
					if (j + 1 < n){
						if (sereja[a[j + 1][k]] == countt[a[j + 1][k]] / 2){

						}
						else{
							flag1 = true;
						}
					}
					if (flag1){
						j++;
					}
					else{
						break;
					}
				}
				vv.push_back(parts(l, j, k, k));
				l = j + 1;
			}
		}
		divide_parts();
		optimize::connect_y(vv);
		//compare(vv);
	}
};
class solve4{
public:
	int n;
	int m;
	int countt[MAX_VAL];
	int a[MAX][MAX];
	void sett(int n_, int m_, int countt1[MAX_VAL], int A[MAX][MAX]){
		n = n_;
		m = m_;
		for (int i = 0; i < MAX_VAL; i++){
			countt[i] = countt1[i];
		}
		for (int i = 0; i < n; i++){
			for (int j = 0; j < m; j++){
				a[i][j] = A[i][j];
			}
		}
	}
	bool use[MAX][MAX];
	int sereja[MAX_VAL];
	vector<parts> vv;
	vector<parts> ato;
	vector<int> order;
	void ini(){
		order.clear();
		for (int k = 0; k < m; k++){
			order.push_back(k);
		}
	}
	void divide_parts(){
		ato.clear();
		for (int i = 0; i < n; i++){
			for (int j = 0; j < m; j++){
				if (use[i][j] == false){
					if (sereja[a[i][j]] == countt[a[i][j]] / 2){
						ato.push_back(parts(i, i, j, j));
					}
					else{
						sereja[a[i][j]]++;
						vv.push_back(parts(i, i, j, j));
					}
				}
			}
		}
		//optimize::connect_y(vv);
		//optimize::connect_y(ato);
		if (vv.size()>ato.size()){
			swap(vv, ato);
		}
	}
	void solve(){
		vv.clear();
		memset(sereja, 0, sizeof(sereja));
		for (int i = 0; i < n; i++){
			for (int j = 0; j < m; j++){
				use[i][j] = false;
			}
		}
		//shuffle(order.begin(), order.end(), default_random_engine(seed));
		random_shuffle(order.begin(), order.end());
		for (int k = 0; k < m; k++){
			int kk = k;
			k = order[k];
			int l = 0;
			while (l < n){
				if (sereja[a[l][k]] == countt[a[l][k]] / 2){
					l++;
					continue;
				}
				int j = l;
				while (j < n){
					sereja[a[j][k]]++;
					use[j][k] = true;
					bool flag1 = false;
					if (j + 1 < n){
						if (sereja[a[j + 1][k]] == countt[a[j + 1][k]] / 2){

						}
						else{
							flag1 = true;
						}
					}
					if (flag1){
						j++;
					}
					else{
						break;
					}
				}
				vv.push_back(parts(l, j, k, k));
				l = j + 1;
			}
			k = kk;
		}
		divide_parts();
		optimize::connect_y(vv);
		//compare(vv);
	}
};
class solve5{
public:
	//make sum rec
	int n;
	int m;
	int countt[MAX_VAL];
	int a[MAX][MAX];
	bool use[MAX][MAX];
	int sereja[MAX_VAL];
	vector<parts> vv;
	int ind = 0;
	int indd = 0;
	bool f = false;
	void solve(int jyo = INT_MAX){
		vv.clear();
		memset(sereja, 0, sizeof(sereja));
		memset(use, false, sizeof(use));
		if (f){
			ind = randxor() % n;
			indd = randxor() % m;
		}
		f = true;
		for (int i = ind; i < n&&vv.size() < jyo; i++){
			for (int j = indd; j < m&&vv.size()<jyo; j++){
				if (use[i][j]){
					continue;
				}
				if (countt[a[i][j]] >> 1 == sereja[a[i][j]]){
					continue;
				}
				int ii = i;
				int jj = j;
				sereja[a[i][j]]++;
				use[i][j] = true;
				while (ii + 1< n || jj + 1 < m){
					bool flag = false;
					bool flag1 = false;
					if (ii + 1 < n){
						bool ng = false;
						for (int k = j; k <= jj; k++){
							sereja[a[ii + 1][k]]++;
							if (sereja[a[ii + 1][k]] > countt[a[ii + 1][k]] >> 1){
								ng = true;
							}
							if (use[ii + 1][k]){
								ng = true;
							}
						}
						for (int k = j; k <= jj; k++){
							sereja[a[ii + 1][k]]--;
						}
						if (ng){

						}
						else{
							flag = true;
						}
					}
					if (jj + 1 < m){
						bool ng = false;
						for (int k = i; k <= ii; k++){
							sereja[a[k][jj + 1]]++;
							if (sereja[a[k][jj + 1]] > countt[a[k][jj + 1]] >> 1){
								ng = true;
							}
							if (use[k][jj + 1]){
								ng = true;
							}
						}
						for (int k = i; k <= ii; k++){
							sereja[a[k][jj + 1]]--;
						}
						if (ng){

						}
						else{
							flag1 = true;
						}
					}
					if (flag == false && flag1 == false){
						break;
					}
					if (flag == true && flag1 == true){
						if (ii>jj){//!!
							flag = false;
						}
						else{
							flag1 = false;
						}
					}
					if (flag){
						for (int k = j; k <= jj; k++){
							sereja[a[ii + 1][k]]++;
							use[ii + 1][k] = true;
						}
						ii++;
					}
					else{
						for (int k = i; k <= ii; k++){
							sereja[a[k][jj + 1]]++;
							use[k][jj + 1] = true;
						}
						jj++;
					}
				}
				vv.push_back(parts(i, ii, j, jj));
			}
			for (int j = 0; j < indd&&vv.size()<jyo; j++){
				if (use[i][j]){
					continue;
				}
				if (countt[a[i][j]] >> 1 == sereja[a[i][j]]){
					continue;
				}
				int ii = i;
				int jj = j;
				sereja[a[i][j]]++;
				use[i][j] = true;
				while (ii + 1< n || jj + 1 < m){
					bool flag = false;
					bool flag1 = false;
					if (ii + 1 < n){
						bool ng = false;
						for (int k = j; k <= jj; k++){
							sereja[a[ii + 1][k]]++;
							if (sereja[a[ii + 1][k]] > countt[a[ii + 1][k]] >> 1){
								ng = true;
							}
							if (use[ii + 1][k]){
								ng = true;
							}
						}
						for (int k = j; k <= jj; k++){
							sereja[a[ii + 1][k]]--;
						}
						if (ng){

						}
						else{
							flag = true;
						}
					}
					if (jj + 1 < m){
						bool ng = false;
						for (int k = i; k <= ii; k++){
							sereja[a[k][jj + 1]]++;
							if (sereja[a[k][jj + 1]] > countt[a[k][jj + 1]] >> 1){
								ng = true;
							}
							if (use[k][jj + 1]){
								ng = true;
							}
						}
						for (int k = i; k <= ii; k++){
							sereja[a[k][jj + 1]]--;
						}
						if (ng){

						}
						else{
							flag1 = true;
						}
					}
					if (flag == false && flag1 == false){
						break;
					}
					if (flag == true && flag1 == true){
						if (ii>jj){//!!
							flag = false;
						}
						else{
							flag1 = false;
						}
					}
					if (flag){
						for (int k = j; k <= jj; k++){
							sereja[a[ii + 1][k]]++;
							use[ii + 1][k] = true;
						}
						ii++;
					}
					else{
						for (int k = i; k <= ii; k++){
							sereja[a[k][jj + 1]]++;
							use[k][jj + 1] = true;
						}
						jj++;
					}
				}
				vv.push_back(parts(i, ii, j, jj));
			}
		}
		for (int i = 0; i < ind&&vv.size()<jyo; i++){
			for (int j = indd; j < m&&vv.size()<jyo; j++){
				if (use[i][j]){
					continue;
				}
				if (countt[a[i][j]] >> 1 == sereja[a[i][j]]){
					continue;
				}
				int ii = i;
				int jj = j;
				sereja[a[i][j]]++;
				use[i][j] = true;
				while (ii + 1< n || jj + 1 < m){
					bool flag = false;
					bool flag1 = false;
					if (ii + 1 < n){
						bool ng = false;
						for (int k = j; k <= jj; k++){
							sereja[a[ii + 1][k]]++;
							if (sereja[a[ii + 1][k]] > countt[a[ii + 1][k]] >> 1){
								ng = true;
							}
							if (use[ii + 1][k]){
								ng = true;
							}
						}
						for (int k = j; k <= jj; k++){
							sereja[a[ii + 1][k]]--;
						}
						if (ng){

						}
						else{
							flag = true;
						}
					}
					if (jj + 1 < m){
						bool ng = false;
						for (int k = i; k <= ii; k++){
							sereja[a[k][jj + 1]]++;
							if (sereja[a[k][jj + 1]] > countt[a[k][jj + 1]] >> 1){
								ng = true;
							}
							if (use[k][jj + 1]){
								ng = true;
							}
						}
						for (int k = i; k <= ii; k++){
							sereja[a[k][jj + 1]]--;
						}
						if (ng){

						}
						else{
							flag1 = true;
						}
					}
					if (flag == false && flag1 == false){
						break;
					}
					if (flag == true && flag1 == true){
						if (ii>jj){//!!
							flag = false;
						}
						else{
							flag1 = false;
						}
					}
					if (flag){
						for (int k = j; k <= jj; k++){
							sereja[a[ii + 1][k]]++;
							use[ii + 1][k] = true;
						}
						ii++;
					}
					else{
						for (int k = i; k <= ii; k++){
							sereja[a[k][jj + 1]]++;
							use[k][jj + 1] = true;
						}
						jj++;
					}
				}
				vv.push_back(parts(i, ii, j, jj));
			}
			for (int j = 0; j < indd&&vv.size()<jyo; j++){
				if (use[i][j]){
					continue;
				}
				if (countt[a[i][j]] >> 1 == sereja[a[i][j]]){
					continue;
				}
				int ii = i;
				int jj = j;
				sereja[a[i][j]]++;
				use[i][j] = true;
				while (ii + 1< n || jj + 1 < m){
					bool flag = false;
					bool flag1 = false;
					if (ii + 1 < n){
						bool ng = false;
						for (int k = j; k <= jj; k++){
							sereja[a[ii + 1][k]]++;
							if (sereja[a[ii + 1][k]] > countt[a[ii + 1][k]] >> 1){
								ng = true;
							}
							if (use[ii + 1][k]){
								ng = true;
							}
						}
						for (int k = j; k <= jj; k++){
							sereja[a[ii + 1][k]]--;
						}
						if (ng){

						}
						else{
							flag = true;
						}
					}
					if (jj + 1 < m){
						bool ng = false;
						for (int k = i; k <= ii; k++){
							sereja[a[k][jj + 1]]++;
							if (sereja[a[k][jj + 1]] > countt[a[k][jj + 1]] >> 1){
								ng = true;
							}
							if (use[k][jj + 1]){
								ng = true;
							}
						}
						for (int k = i; k <= ii; k++){
							sereja[a[k][jj + 1]]--;
						}
						if (ng){

						}
						else{
							flag1 = true;
						}
					}
					if (flag == false && flag1 == false){
						break;
					}
					if (flag == true && flag1 == true){
						if (ii>jj){//!!
							flag = false;
						}
						else{
							flag1 = false;
						}
					}
					if (flag){
						for (int k = j; k <= jj; k++){
							sereja[a[ii + 1][k]]++;
							use[ii + 1][k] = true;
						}
						ii++;
					}
					else{
						for (int k = i; k <= ii; k++){
							sereja[a[k][jj + 1]]++;
							use[k][jj + 1] = true;
						}
						jj++;
					}
				}
				vv.push_back(parts(i, ii, j, jj));
			}
		}
	}
	void non_init(int jyo = INT_MAX){
		for (int i = ind; i < n&&vv.size()<jyo; i++){
			for (int j = indd; j < m&&vv.size()<jyo; j++){
				if (use[i][j]){
					continue;
				}
				if (countt[a[i][j]] >> 1 == sereja[a[i][j]]){
					continue;
				}
				int ii = i;
				int jj = j;
				sereja[a[i][j]]++;
				use[i][j] = true;
				while (ii + 1< n || jj + 1 < m){
					bool flag = false;
					bool flag1 = false;
					if (ii + 1 < n){
						bool ng = false;
						for (int k = j; k <= jj; k++){
							sereja[a[ii + 1][k]]++;
							if (sereja[a[ii + 1][k]] > countt[a[ii + 1][k]] >> 1){
								ng = true;
							}
							if (use[ii + 1][k]){
								ng = true;
							}
						}
						for (int k = j; k <= jj; k++){
							sereja[a[ii + 1][k]]--;
						}
						if (ng){

						}
						else{
							flag = true;
						}
					}
					if (jj + 1 < m){
						bool ng = false;
						for (int k = i; k <= ii; k++){
							sereja[a[k][jj + 1]]++;
							if (sereja[a[k][jj + 1]] > countt[a[k][jj + 1]] >> 1){
								ng = true;
							}
							if (use[k][jj + 1]){
								ng = true;
							}
						}
						for (int k = i; k <= ii; k++){
							sereja[a[k][jj + 1]]--;
						}
						if (ng){

						}
						else{
							flag1 = true;
						}
					}
					if (flag == false && flag1 == false){
						break;
					}
					if (flag == true && flag1 == true){
						if (ii>jj){//!!
							flag = false;
						}
						else{
							flag1 = false;
						}
					}
					if (flag){
						for (int k = j; k <= jj; k++){
							sereja[a[ii + 1][k]]++;
							use[ii + 1][k] = true;
						}
						ii++;
					}
					else{
						for (int k = i; k <= ii; k++){
							sereja[a[k][jj + 1]]++;
							use[k][jj + 1] = true;
						}
						jj++;
					}
				}
				vv.push_back(parts(i, ii, j, jj));
			}
			for (int j = 0; j < indd&&vv.size()<jyo; j++){
				if (use[i][j]){
					continue;
				}
				if (countt[a[i][j]] >> 1 == sereja[a[i][j]]){
					continue;
				}
				int ii = i;
				int jj = j;
				sereja[a[i][j]]++;
				use[i][j] = true;
				while (ii + 1< n || jj + 1 < m){
					bool flag = false;
					bool flag1 = false;
					if (ii + 1 < n){
						bool ng = false;
						for (int k = j; k <= jj; k++){
							sereja[a[ii + 1][k]]++;
							if (sereja[a[ii + 1][k]] > countt[a[ii + 1][k]] >> 1){
								ng = true;
							}
							if (use[ii + 1][k]){
								ng = true;
							}
						}
						for (int k = j; k <= jj; k++){
							sereja[a[ii + 1][k]]--;
						}
						if (ng){

						}
						else{
							flag = true;
						}
					}
					if (jj + 1 < m){
						bool ng = false;
						for (int k = i; k <= ii; k++){
							sereja[a[k][jj + 1]]++;
							if (sereja[a[k][jj + 1]] > countt[a[k][jj + 1]] >> 1){
								ng = true;
							}
							if (use[k][jj + 1]){
								ng = true;
							}
						}
						for (int k = i; k <= ii; k++){
							sereja[a[k][jj + 1]]--;
						}
						if (ng){

						}
						else{
							flag1 = true;
						}
					}
					if (flag == false && flag1 == false){
						break;
					}
					if (flag == true && flag1 == true){
						if (ii>jj){//!!
							flag = false;
						}
						else{
							flag1 = false;
						}
					}
					if (flag){
						for (int k = j; k <= jj; k++){
							sereja[a[ii + 1][k]]++;
							use[ii + 1][k] = true;
						}
						ii++;
					}
					else{
						for (int k = i; k <= ii; k++){
							sereja[a[k][jj + 1]]++;
							use[k][jj + 1] = true;
						}
						jj++;
					}
				}
				vv.push_back(parts(i, ii, j, jj));
			}
		}
		for (int i = 0; i < ind&&vv.size()<jyo; i++){
			for (int j = indd; j < m&&vv.size()<jyo; j++){
				if (use[i][j]){
					continue;
				}
				if (countt[a[i][j]] >> 1 == sereja[a[i][j]]){
					continue;
				}
				int ii = i;
				int jj = j;
				sereja[a[i][j]]++;
				use[i][j] = true;
				while (ii + 1< n || jj + 1 < m){
					bool flag = false;
					bool flag1 = false;
					if (ii + 1 < n){
						bool ng = false;
						for (int k = j; k <= jj; k++){
							sereja[a[ii + 1][k]]++;
							if (sereja[a[ii + 1][k]] > countt[a[ii + 1][k]] >> 1){
								ng = true;
							}
							if (use[ii + 1][k]){
								ng = true;
							}
						}
						for (int k = j; k <= jj; k++){
							sereja[a[ii + 1][k]]--;
						}
						if (ng){

						}
						else{
							flag = true;
						}
					}
					if (jj + 1 < m){
						bool ng = false;
						for (int k = i; k <= ii; k++){
							sereja[a[k][jj + 1]]++;
							if (sereja[a[k][jj + 1]] > countt[a[k][jj + 1]] >> 1){
								ng = true;
							}
							if (use[k][jj + 1]){
								ng = true;
							}
						}
						for (int k = i; k <= ii; k++){
							sereja[a[k][jj + 1]]--;
						}
						if (ng){

						}
						else{
							flag1 = true;
						}
					}
					if (flag == false && flag1 == false){
						break;
					}
					if (flag == true && flag1 == true){
						if (ii>jj){//!!
							flag = false;
						}
						else{
							flag1 = false;
						}
					}
					if (flag){
						for (int k = j; k <= jj; k++){
							sereja[a[ii + 1][k]]++;
							use[ii + 1][k] = true;
						}
						ii++;
					}
					else{
						for (int k = i; k <= ii; k++){
							sereja[a[k][jj + 1]]++;
							use[k][jj + 1] = true;
						}
						jj++;
					}
				}
				vv.push_back(parts(i, ii, j, jj));
			}
			for (int j = 0; j < indd&&vv.size()<jyo; j++){
				if (use[i][j]){
					continue;
				}
				if (countt[a[i][j]] >> 1 == sereja[a[i][j]]){
					continue;
				}
				int ii = i;
				int jj = j;
				sereja[a[i][j]]++;
				use[i][j] = true;
				while (ii + 1< n || jj + 1 < m){
					bool flag = false;
					bool flag1 = false;
					if (ii + 1 < n){
						bool ng = false;
						for (int k = j; k <= jj; k++){
							sereja[a[ii + 1][k]]++;
							if (sereja[a[ii + 1][k]] > countt[a[ii + 1][k]] >> 1){
								ng = true;
							}
							if (use[ii + 1][k]){
								ng = true;
							}
						}
						for (int k = j; k <= jj; k++){
							sereja[a[ii + 1][k]]--;
						}
						if (ng){

						}
						else{
							flag = true;
						}
					}
					if (jj + 1 < m){
						bool ng = false;
						for (int k = i; k <= ii; k++){
							sereja[a[k][jj + 1]]++;
							if (sereja[a[k][jj + 1]] > countt[a[k][jj + 1]] >> 1){
								ng = true;
							}
							if (use[k][jj + 1]){
								ng = true;
							}
						}
						for (int k = i; k <= ii; k++){
							sereja[a[k][jj + 1]]--;
						}
						if (ng){

						}
						else{
							flag1 = true;
						}
					}
					if (flag == false && flag1 == false){
						break;
					}
					if (flag == true && flag1 == true){
						if (ii>jj){//!!
							flag = false;
						}
						else{
							flag1 = false;
						}
					}
					if (flag){
						for (int k = j; k <= jj; k++){
							sereja[a[ii + 1][k]]++;
							use[ii + 1][k] = true;
						}
						ii++;
					}
					else{
						for (int k = i; k <= ii; k++){
							sereja[a[k][jj + 1]]++;
							use[k][jj + 1] = true;
						}
						jj++;
					}
				}
				vv.push_back(parts(i, ii, j, jj));
			}
		}
	}
	void random_place(int val, int jyo = INT_MAX){
		memset(use, false, sizeof(use));
		memset(sereja, 0, sizeof(sereja));
		vv.clear();
		for (int tt = 0; tt < val&&vv.size()<jyo; tt++){
			int i = randxor() % n;
			int j = randxor() % m;
			if (use[i][j]){
				continue;
			}
			if (countt[a[i][j]] >> 1 == sereja[a[i][j]]){
				continue;
			}
			int ii = i;
			int jj = j;
			sereja[a[i][j]]++;
			use[i][j] = true;
			while (ii + 1< n || jj + 1 < m){
				bool flag = false;
				bool flag1 = false;
				if (ii + 1 < n){
					bool ng = false;
					for (int k = j; k <= jj; k++){
						sereja[a[ii + 1][k]]++;
						if (sereja[a[ii + 1][k]] > countt[a[ii + 1][k]] >> 1){
							ng = true;
						}
						if (use[ii + 1][k]){
							ng = true;
						}
					}
					for (int k = j; k <= jj; k++){
						sereja[a[ii + 1][k]]--;
					}
					if (ng){

					}
					else{
						flag = true;
					}
				}
				if (jj + 1 < m){
					bool ng = false;
					for (int k = i; k <= ii; k++){
						sereja[a[k][jj + 1]]++;
						if (sereja[a[k][jj + 1]] > countt[a[k][jj + 1]] >> 1){
							ng = true;
						}
						if (use[k][jj + 1]){
							ng = true;
						}
					}
					for (int k = i; k <= ii; k++){
						sereja[a[k][jj + 1]]--;
					}
					if (ng){

					}
					else{
						flag1 = true;
					}
				}
				if (flag == false && flag1 == false){
					break;
				}
				if (flag == true && flag1 == true){
					/*if (randxor() % 2){
					flag = false;
					}
					else{
					flag1 = false;
					}*/
					if (ii>jj){//!!
						flag = false;
					}
					else{
						flag1 = false;
					}
				}
				if (flag){
					for (int k = j; k <= jj; k++){
						sereja[a[ii + 1][k]]++;
						use[ii + 1][k] = true;
					}
					ii++;
				}
				else{
					for (int k = i; k <= ii; k++){
						sereja[a[k][jj + 1]]++;
						use[k][jj + 1] = true;
					}
					jj++;
				}
			}
			vv.push_back(parts(i, ii, j, jj));
		}
		non_init();
	}
};
class solve6{
public:
	//make sum rec
	int n;
	int m;
	int countt[MAX_VAL];
	int a[MAX][MAX];
	bool use[MAX][MAX];
	int sereja[MAX_VAL];
	vector<parts> vv;
	int ind = 0;
	int indd = 0;
	bool f = false;
	void solve(int jyo = INT_MAX){
		vv.clear();
		memset(sereja, 0, sizeof(sereja));
		memset(use, false, sizeof(use));
		if (f){
			ind = randxor() % n;
			indd = randxor() % m;
		}
		f = true;
		for (int j = indd; j < m&&vv.size() < jyo; j++){
			for (int i = ind; i < n&&vv.size()<jyo; i++){
				if (use[i][j]){
					continue;
				}
				if (countt[a[i][j]] >> 1 == sereja[a[i][j]]){
					continue;
				}
				int ii = i;
				int jj = j;
				sereja[a[i][j]]++;
				use[i][j] = true;
				while (ii + 1< n || jj + 1 < m){
					bool flag = false;
					bool flag1 = false;
					if (ii + 1 < n){
						bool ng = false;
						for (int k = j; k <= jj; k++){
							sereja[a[ii + 1][k]]++;
							if (sereja[a[ii + 1][k]] > countt[a[ii + 1][k]] >> 1){
								ng = true;
							}
							if (use[ii + 1][k]){
								ng = true;
							}
						}
						for (int k = j; k <= jj; k++){
							sereja[a[ii + 1][k]]--;
						}
						if (ng){

						}
						else{
							flag = true;
						}
					}
					if (jj + 1 < m){
						bool ng = false;
						for (int k = i; k <= ii; k++){
							sereja[a[k][jj + 1]]++;
							if (sereja[a[k][jj + 1]] > countt[a[k][jj + 1]] >> 1){
								ng = true;
							}
							if (use[k][jj + 1]){
								ng = true;
							}
						}
						for (int k = i; k <= ii; k++){
							sereja[a[k][jj + 1]]--;
						}
						if (ng){

						}
						else{
							flag1 = true;
						}
					}
					if (flag == false && flag1 == false){
						break;
					}
					if (flag == true && flag1 == true){
						/*if (randxor() % 2){
						flag = false;
						}
						else{
						flag1 = false;
						}*/
						if (ii>jj){//!!
							flag = false;
						}
						else{
							flag1 = false;
						}
					}
					if (flag){
						for (int k = j; k <= jj; k++){
							sereja[a[ii + 1][k]]++;
							use[ii + 1][k] = true;
						}
						ii++;
					}
					else{
						for (int k = i; k <= ii; k++){
							sereja[a[k][jj + 1]]++;
							use[k][jj + 1] = true;
						}
						jj++;
					}
				}
				vv.push_back(parts(i, ii, j, jj));
			}
			for (int i = 0; i < ind&&vv.size()<jyo; i++){
				if (use[i][j]){
					continue;
				}
				if (countt[a[i][j]] >> 1 == sereja[a[i][j]]){
					continue;
				}
				int ii = i;
				int jj = j;
				sereja[a[i][j]]++;
				use[i][j] = true;
				while (ii + 1< n || jj + 1 < m){
					bool flag = false;
					bool flag1 = false;
					if (ii + 1 < n){
						bool ng = false;
						for (int k = j; k <= jj; k++){
							sereja[a[ii + 1][k]]++;
							if (sereja[a[ii + 1][k]] > countt[a[ii + 1][k]] >> 1){
								ng = true;
							}
							if (use[ii + 1][k]){
								ng = true;
							}
						}
						for (int k = j; k <= jj; k++){
							sereja[a[ii + 1][k]]--;
						}
						if (ng){

						}
						else{
							flag = true;
						}
					}
					if (jj + 1 < m){
						bool ng = false;
						for (int k = i; k <= ii; k++){
							sereja[a[k][jj + 1]]++;
							if (sereja[a[k][jj + 1]] > countt[a[k][jj + 1]] >> 1){
								ng = true;
							}
							if (use[k][jj + 1]){
								ng = true;
							}
						}
						for (int k = i; k <= ii; k++){
							sereja[a[k][jj + 1]]--;
						}
						if (ng){

						}
						else{
							flag1 = true;
						}
					}
					if (flag == false && flag1 == false){
						break;
					}
					if (flag == true && flag1 == true){
						/*if (randxor() % 2){
						flag = false;
						}
						else{
						flag1 = false;
						}*/
						if (ii>jj){//!!
							flag = false;
						}
						else{
							flag1 = false;
						}
					}
					if (flag){
						for (int k = j; k <= jj; k++){
							sereja[a[ii + 1][k]]++;
							use[ii + 1][k] = true;
						}
						ii++;
					}
					else{
						for (int k = i; k <= ii; k++){
							sereja[a[k][jj + 1]]++;
							use[k][jj + 1] = true;
						}
						jj++;
					}
				}
				vv.push_back(parts(i, ii, j, jj));
			}
		}
		for (int j = 0; j < indd&&vv.size()<jyo; j++){
			for (int i = ind; i < n&&vv.size()<jyo; i++){
				if (use[i][j]){
					continue;
				}
				if (countt[a[i][j]] >> 1 == sereja[a[i][j]]){
					continue;
				}
				int ii = i;
				int jj = j;
				sereja[a[i][j]]++;
				use[i][j] = true;
				while (ii + 1< n || jj + 1 < m){
					bool flag = false;
					bool flag1 = false;
					if (ii + 1 < n){
						bool ng = false;
						for (int k = j; k <= jj; k++){
							sereja[a[ii + 1][k]]++;
							if (sereja[a[ii + 1][k]] > countt[a[ii + 1][k]] >> 1){
								ng = true;
							}
							if (use[ii + 1][k]){
								ng = true;
							}
						}
						for (int k = j; k <= jj; k++){
							sereja[a[ii + 1][k]]--;
						}
						if (ng){

						}
						else{
							flag = true;
						}
					}
					if (jj + 1 < m){
						bool ng = false;
						for (int k = i; k <= ii; k++){
							sereja[a[k][jj + 1]]++;
							if (sereja[a[k][jj + 1]] > countt[a[k][jj + 1]] >> 1){
								ng = true;
							}
							if (use[k][jj + 1]){
								ng = true;
							}
						}
						for (int k = i; k <= ii; k++){
							sereja[a[k][jj + 1]]--;
						}
						if (ng){

						}
						else{
							flag1 = true;
						}
					}
					if (flag == false && flag1 == false){
						break;
					}
					if (flag == true && flag1 == true){
						/*if (randxor() % 2){
						flag = false;
						}
						else{
						flag1 = false;
						}*/
						if (ii>jj){//!!
							flag = false;
						}
						else{
							flag1 = false;
						}
					}
					if (flag){
						for (int k = j; k <= jj; k++){
							sereja[a[ii + 1][k]]++;
							use[ii + 1][k] = true;
						}
						ii++;
					}
					else{
						for (int k = i; k <= ii; k++){
							sereja[a[k][jj + 1]]++;
							use[k][jj + 1] = true;
						}
						jj++;
					}
				}
				vv.push_back(parts(i, ii, j, jj));
			}
			for (int i = 0; i < ind&&vv.size()<jyo; i++){
				if (use[i][j]){
					continue;
				}
				if (countt[a[i][j]] >> 1 == sereja[a[i][j]]){
					continue;
				}
				int ii = i;
				int jj = j;
				sereja[a[i][j]]++;
				use[i][j] = true;
				while (ii + 1< n || jj + 1 < m){
					bool flag = false;
					bool flag1 = false;
					if (ii + 1 < n){
						bool ng = false;
						for (int k = j; k <= jj; k++){
							sereja[a[ii + 1][k]]++;
							if (sereja[a[ii + 1][k]] > countt[a[ii + 1][k]] >> 1){
								ng = true;
							}
							if (use[ii + 1][k]){
								ng = true;
							}
						}
						for (int k = j; k <= jj; k++){
							sereja[a[ii + 1][k]]--;
						}
						if (ng){

						}
						else{
							flag = true;
						}
					}
					if (jj + 1 < m){
						bool ng = false;
						for (int k = i; k <= ii; k++){
							sereja[a[k][jj + 1]]++;
							if (sereja[a[k][jj + 1]] > countt[a[k][jj + 1]] >> 1){
								ng = true;
							}
							if (use[k][jj + 1]){
								ng = true;
							}
						}
						for (int k = i; k <= ii; k++){
							sereja[a[k][jj + 1]]--;
						}
						if (ng){

						}
						else{
							flag1 = true;
						}
					}
					if (flag == false && flag1 == false){
						break;
					}
					if (flag == true && flag1 == true){
						if (ii>jj){//!!
							flag = false;
						}
						else{
							flag1 = false;
						}
					}
					if (flag){
						for (int k = j; k <= jj; k++){
							sereja[a[ii + 1][k]]++;
							use[ii + 1][k] = true;
						}
						ii++;
					}
					else{
						for (int k = i; k <= ii; k++){
							sereja[a[k][jj + 1]]++;
							use[k][jj + 1] = true;
						}
						jj++;
					}
				}
				vv.push_back(parts(i, ii, j, jj));
			}
		}
	}
	void non_init(int jyo = INT_MAX){
		if (f){
			ind = randxor() % n;
			indd = randxor() % m;
		}
		f = true;
		for (int j = indd; j < m&&vv.size() < jyo; j++){
			for (int i = ind; i < n&&vv.size()<jyo; i++){
				if (use[i][j]){
					continue;
				}
				if (countt[a[i][j]] >> 1 == sereja[a[i][j]]){
					continue;
				}
				int ii = i;
				int jj = j;
				sereja[a[i][j]]++;
				use[i][j] = true;
				while (ii + 1< n || jj + 1 < m){
					bool flag = false;
					bool flag1 = false;
					if (ii + 1 < n){
						bool ng = false;
						for (int k = j; k <= jj; k++){
							sereja[a[ii + 1][k]]++;
							if (sereja[a[ii + 1][k]] > countt[a[ii + 1][k]] >> 1){
								ng = true;
							}
							if (use[ii + 1][k]){
								ng = true;
							}
						}
						for (int k = j; k <= jj; k++){
							sereja[a[ii + 1][k]]--;
						}
						if (ng){

						}
						else{
							flag = true;
						}
					}
					if (jj + 1 < m){
						bool ng = false;
						for (int k = i; k <= ii; k++){
							sereja[a[k][jj + 1]]++;
							if (sereja[a[k][jj + 1]] > countt[a[k][jj + 1]] >> 1){
								ng = true;
							}
							if (use[k][jj + 1]){
								ng = true;
							}
						}
						for (int k = i; k <= ii; k++){
							sereja[a[k][jj + 1]]--;
						}
						if (ng){

						}
						else{
							flag1 = true;
						}
					}
					if (flag == false && flag1 == false){
						break;
					}
					if (flag == true && flag1 == true){
						/*if (randxor() % 2){
						flag = false;
						}
						else{
						flag1 = false;
						}*/
						if (ii>jj){//!!
							flag = false;
						}
						else{
							flag1 = false;
						}
					}
					if (flag){
						for (int k = j; k <= jj; k++){
							sereja[a[ii + 1][k]]++;
							use[ii + 1][k] = true;
						}
						ii++;
					}
					else{
						for (int k = i; k <= ii; k++){
							sereja[a[k][jj + 1]]++;
							use[k][jj + 1] = true;
						}
						jj++;
					}
				}
				vv.push_back(parts(i, ii, j, jj));
			}
			for (int i = 0; i < ind&&vv.size()<jyo; i++){
				if (use[i][j]){
					continue;
				}
				if (countt[a[i][j]] >> 1 == sereja[a[i][j]]){
					continue;
				}
				int ii = i;
				int jj = j;
				sereja[a[i][j]]++;
				use[i][j] = true;
				while (ii + 1< n || jj + 1 < m){
					bool flag = false;
					bool flag1 = false;
					if (ii + 1 < n){
						bool ng = false;
						for (int k = j; k <= jj; k++){
							sereja[a[ii + 1][k]]++;
							if (sereja[a[ii + 1][k]] > countt[a[ii + 1][k]] >> 1){
								ng = true;
							}
							if (use[ii + 1][k]){
								ng = true;
							}
						}
						for (int k = j; k <= jj; k++){
							sereja[a[ii + 1][k]]--;
						}
						if (ng){

						}
						else{
							flag = true;
						}
					}
					if (jj + 1 < m){
						bool ng = false;
						for (int k = i; k <= ii; k++){
							sereja[a[k][jj + 1]]++;
							if (sereja[a[k][jj + 1]] > countt[a[k][jj + 1]] >> 1){
								ng = true;
							}
							if (use[k][jj + 1]){
								ng = true;
							}
						}
						for (int k = i; k <= ii; k++){
							sereja[a[k][jj + 1]]--;
						}
						if (ng){

						}
						else{
							flag1 = true;
						}
					}
					if (flag == false && flag1 == false){
						break;
					}
					if (flag == true && flag1 == true){
						/*if (randxor() % 2){
						flag = false;
						}
						else{
						flag1 = false;
						}*/
						if (ii>jj){//!!
							flag = false;
						}
						else{
							flag1 = false;
						}
					}
					if (flag){
						for (int k = j; k <= jj; k++){
							sereja[a[ii + 1][k]]++;
							use[ii + 1][k] = true;
						}
						ii++;
					}
					else{
						for (int k = i; k <= ii; k++){
							sereja[a[k][jj + 1]]++;
							use[k][jj + 1] = true;
						}
						jj++;
					}
				}
				vv.push_back(parts(i, ii, j, jj));
			}
		}
		for (int j = 0; j < indd&&vv.size()<jyo; j++){
			for (int i = ind; i < n&&vv.size()<jyo; i++){
				if (use[i][j]){
					continue;
				}
				if (countt[a[i][j]] >> 1 == sereja[a[i][j]]){
					continue;
				}
				int ii = i;
				int jj = j;
				sereja[a[i][j]]++;
				use[i][j] = true;
				while (ii + 1< n || jj + 1 < m){
					bool flag = false;
					bool flag1 = false;
					if (ii + 1 < n){
						bool ng = false;
						for (int k = j; k <= jj; k++){
							sereja[a[ii + 1][k]]++;
							if (sereja[a[ii + 1][k]] > countt[a[ii + 1][k]] >> 1){
								ng = true;
							}
							if (use[ii + 1][k]){
								ng = true;
							}
						}
						for (int k = j; k <= jj; k++){
							sereja[a[ii + 1][k]]--;
						}
						if (ng){

						}
						else{
							flag = true;
						}
					}
					if (jj + 1 < m){
						bool ng = false;
						for (int k = i; k <= ii; k++){
							sereja[a[k][jj + 1]]++;
							if (sereja[a[k][jj + 1]] > countt[a[k][jj + 1]] >> 1){
								ng = true;
							}
							if (use[k][jj + 1]){
								ng = true;
							}
						}
						for (int k = i; k <= ii; k++){
							sereja[a[k][jj + 1]]--;
						}
						if (ng){

						}
						else{
							flag1 = true;
						}
					}
					if (flag == false && flag1 == false){
						break;
					}
					if (flag == true && flag1 == true){
						/*if (randxor() % 2){
						flag = false;
						}
						else{
						flag1 = false;
						}*/
						if (ii>jj){//!!
							flag = false;
						}
						else{
							flag1 = false;
						}
					}
					if (flag){
						for (int k = j; k <= jj; k++){
							sereja[a[ii + 1][k]]++;
							use[ii + 1][k] = true;
						}
						ii++;
					}
					else{
						for (int k = i; k <= ii; k++){
							sereja[a[k][jj + 1]]++;
							use[k][jj + 1] = true;
						}
						jj++;
					}
				}
				vv.push_back(parts(i, ii, j, jj));
			}
			for (int i = 0; i < ind&&vv.size()<jyo; i++){
				if (use[i][j]){
					continue;
				}
				if (countt[a[i][j]] >> 1 == sereja[a[i][j]]){
					continue;
				}
				int ii = i;
				int jj = j;
				sereja[a[i][j]]++;
				use[i][j] = true;
				while (ii + 1< n || jj + 1 < m){
					bool flag = false;
					bool flag1 = false;
					if (ii + 1 < n){
						bool ng = false;
						for (int k = j; k <= jj; k++){
							sereja[a[ii + 1][k]]++;
							if (sereja[a[ii + 1][k]] > countt[a[ii + 1][k]] >> 1){
								ng = true;
							}
							if (use[ii + 1][k]){
								ng = true;
							}
						}
						for (int k = j; k <= jj; k++){
							sereja[a[ii + 1][k]]--;
						}
						if (ng){

						}
						else{
							flag = true;
						}
					}
					if (jj + 1 < m){
						bool ng = false;
						for (int k = i; k <= ii; k++){
							sereja[a[k][jj + 1]]++;
							if (sereja[a[k][jj + 1]] > countt[a[k][jj + 1]] >> 1){
								ng = true;
							}
							if (use[k][jj + 1]){
								ng = true;
							}
						}
						for (int k = i; k <= ii; k++){
							sereja[a[k][jj + 1]]--;
						}
						if (ng){

						}
						else{
							flag1 = true;
						}
					}
					if (flag == false && flag1 == false){
						break;
					}
					if (flag == true && flag1 == true){
						if (ii>jj){//!!
							flag = false;
						}
						else{
							flag1 = false;
						}
					}
					if (flag){
						for (int k = j; k <= jj; k++){
							sereja[a[ii + 1][k]]++;
							use[ii + 1][k] = true;
						}
						ii++;
					}
					else{
						for (int k = i; k <= ii; k++){
							sereja[a[k][jj + 1]]++;
							use[k][jj + 1] = true;
						}
						jj++;
					}
				}
				vv.push_back(parts(i, ii, j, jj));
			}
		}
	}
	void random_place(int val, int jyo = INT_MAX){
		memset(use, false, sizeof(use));
		memset(sereja, 0, sizeof(sereja));
		vv.clear();
		for (int tt = 0; tt < val&&vv.size()<jyo; tt++){
			int i = randxor() % n;
			int j = randxor() % m;
			if (use[i][j]){
				continue;
			}
			if (countt[a[i][j]] >> 1 == sereja[a[i][j]]){
				continue;
			}
			int ii = i;
			int jj = j;
			sereja[a[i][j]]++;
			use[i][j] = true;
			while (ii + 1< n || jj + 1 < m){
				bool flag = false;
				bool flag1 = false;
				if (ii + 1 < n){
					bool ng = false;
					for (int k = j; k <= jj; k++){
						sereja[a[ii + 1][k]]++;
						if (sereja[a[ii + 1][k]] > countt[a[ii + 1][k]] >> 1){
							ng = true;
						}
						if (use[ii + 1][k]){
							ng = true;
						}
					}
					for (int k = j; k <= jj; k++){
						sereja[a[ii + 1][k]]--;
					}
					if (ng){

					}
					else{
						flag = true;
					}
				}
				if (jj + 1 < m){
					bool ng = false;
					for (int k = i; k <= ii; k++){
						sereja[a[k][jj + 1]]++;
						if (sereja[a[k][jj + 1]] > countt[a[k][jj + 1]] >> 1){
							ng = true;
						}
						if (use[k][jj + 1]){
							ng = true;
						}
					}
					for (int k = i; k <= ii; k++){
						sereja[a[k][jj + 1]]--;
					}
					if (ng){

					}
					else{
						flag1 = true;
					}
				}
				if (flag == false && flag1 == false){
					break;
				}
				if (flag == true && flag1 == true){
					/*if (randxor() % 2){
					flag = false;
					}
					else{
					flag1 = false;
					}*/
					if (ii>jj){//!!
						flag = false;
					}
					else{
						flag1 = false;
					}
				}
				if (flag){
					for (int k = j; k <= jj; k++){
						sereja[a[ii + 1][k]]++;
						use[ii + 1][k] = true;
					}
					ii++;
				}
				else{
					for (int k = i; k <= ii; k++){
						sereja[a[k][jj + 1]]++;
						use[k][jj + 1] = true;
					}
					jj++;
				}
			}
			vv.push_back(parts(i, ii, j, jj));
		}
		non_init();
	}
};
class Testcase{
public:
	int n;
	int m;
	int a[MAX][MAX];
	int countt[MAX_VAL];
	/*Answer*/
	int ans;
	vector<parts> outt;
	void input(){
		scanf("%d%d", &n, &m);
		for (int i = 0; i < n; i++){
			for (int j = 0; j < m; j++){
				scanf("%d", &a[i][j]);
			}
		}
	}
	void init(){
		memset(countt, 0, sizeof(countt));
		for (int i = 0; i < n; i++){
			for (int j = 0; j < m; j++){
				countt[a[i][j]]++;
			}
		}
		ans = INT_MAX;
		outt.clear();
	}
	solve1 solve11;
	solve2 solve22;
	solve3 solve33;
	solve4 solve44;
	solve5 solve55;
	solve6 solve66;
	bool compare(vector<parts> &a){
		if (ans>a.size()){  //DO NOT >=
			ans = a.size();
			outt = a;
			return true;
		}
		return false;
	}
	void solve(){
		solve11.solve();
		compare(solve11.vv);
		solve22.ini();
		solve22.solve();
		compare(solve22.vv);
		solve33.solve();
		compare(solve33.vv);
		solve44.ini();
		solve44.solve();
		compare(solve44.vv);
		solve55.solve();
		compare(solve55.vv);
		solve66.solve();
		compare(solve66.vv);
	}
	void output(){
		printf("%d\n", ans);
		for (int i = 0; i < outt.size(); i++){
			printf("%d %d %d %d\n", outt[i].x + 1, outt[i].y + 1, outt[i].xx + 1, outt[i].yy + 1);
		}
	}
#define MOD 30
	int cnt = 0;
	void update(){
		if (ans == 1){
			return;
		}
		cnt++;
		if (cnt <= SOLVE_LIM){
			solve22.solve();
			compare(solve22.vv);
			solve44.solve();
			compare(solve44.vv);
		}
		solve66.solve();
		compare(solve66.vv);
		solve66.random_place(randxor() % 10 + 1, ans);
		compare(solve66.vv);
		solve55.solve(ans);
		compare(solve55.vv);
		solve55.random_place(randxor() % 10 + 1, ans);
		compare(solve55.vv);
	}
	Testcase(){
		memset(countt, 0, sizeof(countt));
		input();
		init();
		solve11.n = n;
		solve11.m = m;
		solve22.n = n;
		solve22.m = m;
		solve33.n = n;
		solve33.m = m;
		solve44.n = n;
		solve44.m = m;
		solve55.n = n;
		solve55.m = m;
		solve66.n = n;
		solve66.m = m;
		for (int i = 0; i < MAX_VAL; i++){
			solve11.countt[i] = countt[i];
			solve22.countt[i] = countt[i];
			solve33.countt[i] = countt[i];
			solve44.countt[i] = countt[i];
			solve55.countt[i] = countt[i];
			solve66.countt[i] = countt[i];
		}
		for (int i = 0; i < n; i++){
			for (int j = 0; j < m; j++){
				solve11.a[i][j] = a[i][j];
				solve22.a[i][j] = a[i][j];
				solve33.a[i][j] = a[i][j];
				solve44.a[i][j] = a[i][j];
				solve55.a[i][j] = a[i][j];
				solve66.a[i][j] = a[i][j];
			}
		}
		/*solve11.sett(n, m, countt, a);
		solve22.sett(n, m, countt, a);
		solve33.sett(n, m, countt, a);
		solve44.sett(n, m, countt, a);*/
		solve();
	}
#define SMALL 8
	void update2(){
		if (outt.size() == 1){
			return;
		}
		if (randxor() % 2){
			solve55.vv.clear();
			memset(solve55.use, false, sizeof(solve55.use));
			memset(solve55.sereja, 0, sizeof(solve55.sereja));
			for (int i = 0; i < outt.size(); i++){
				if (outt[i].area() <= SMALL){

				}
				else{
					solve55.vv.push_back(outt[i]);
					for (int k = outt[i].x; k <= outt[i].xx; k++){
						for (int kk = outt[i].y; kk <= outt[i].yy; kk++){
							solve55.use[k][kk] = true;
							solve55.sereja[a[k][kk]]++;
						}
					}
				}
			}
			solve55.non_init(outt.size());
			compare(solve55.vv);
		}
		else{
			solve66.vv.clear();
			memset(solve66.use, false, sizeof(solve66.use));
			memset(solve66.sereja, 0, sizeof(solve66.sereja));
			for (int i = 0; i < outt.size(); i++){
				if (outt[i].area() <= SMALL){

				}
				else{
					solve66.vv.push_back(outt[i]);
					for (int k = outt[i].x; k <= outt[i].xx; k++){
						for (int kk = outt[i].y; kk <= outt[i].yy; kk++){
							solve66.use[k][kk] = true;
							solve66.sereja[a[k][kk]]++;
						}
					}
				}
			}
			solve66.non_init(outt.size());
			compare(solve66.vv);
		}
	}
};
vector<Testcase> v;
#define TIME_LIMIT 9.9
int main(){
	scanf("%d", &t);
	for (int i = 0; i < t; i++){
		v.push_back(Testcase());
	}
	int cc = 0;
	int cnt = -1;
	double tim = 0.0;
	tim = clock() / (double)(CLOCKS_PER_SEC);
	int mod = 10;
	while (tim< TIME_LIMIT){
		cnt++;
		mod = ceil(11.0 - tim);
		for (int i = 0; i < t; i++){
			if (cnt%mod <= 4){
				v[i].update2();
			}
			else{
				v[i].update();
			}
		}
		tim = clock() / (double)(CLOCKS_PER_SEC);
	}
	for (int i = 0; i < t; i++){
		v[i].output();
	}
	return 0;
}